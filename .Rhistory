"should be larger than the first")
})
test_that("Delay or p cannot be too large", {
expect_error(hystar_sim(z = 1:3, r = c(2, 2), d = 3,
phi_R0 = 1, phi_R1 = 2),
"than the length of `z`")
expect_error(hystar_sim(z = 1:3, r = c(2, 2.2), d = 1,
phi_R0 = 1, phi_R1 = c(0, .1, .1, .1)),
"than the length of `z`")
})
test_that("Delay or regime order cannot be too large", {
expect_error(hystar_sim(z = 1:3, r = c(2, 2), d = 3,
phi_R0 = 1, phi_R1 = 2),
"than the length of `z`")
expect_error(hystar_sim(z = 1:3, r = c(2, 2.2), d = 1,
phi_R0 = 1, phi_R1 = c(0, .1, .1, .1)),
"than the length of `z`")
})
hystar_sim(z = 1:3, r = c(2, 2.2), d = 1,
phi_R0 = 1, phi_R1 = c(0, .1, .1, .1))
z = 1:3
r = c(2, 2.2)
d = 1
phi_R0 = 1
phi_R1 = c(0, .1, .1, .1)
check_hystar_sim_input(z, r, d, phi_R0, phi_R1, resvar, start_regime)
p0 <- get_order(phi_R0)
p1 <- get_order(phi_R0)
check_z(z)
check_r_sim(r, z)
check_whole_nn(d)
check_zdp(z, d, p0, p1)
d >= length(z)
length(z)
max(p0, p1)
p0
p1
devtools::load_all(".")
test_that("Delay or regime order cannot be too large", {
expect_error(hystar_sim(z = 1:3, r = c(2, 2), d = 3,
phi_R0 = 1, phi_R1 = 2),
"than the length of `z`")
expect_error(hystar_sim(z = 1:3, r = c(2, 2.2), d = 1,
phi_R0 = 1, phi_R1 = c(0, .1, .1, .1)),
"than the length of `z`")
})
test_that("Delay or regime order cannot be too large", {
expect_error(hystar_sim(z = 1:3, r = c(2, 2.2), d = 3,
phi_R0 = 1, phi_R1 = 2),
"than the length of `z`")
expect_error(hystar_sim(z = 1:3, r = c(2, 2.2), d = 1,
phi_R0 = 1, phi_R1 = c(0, .1, .1, .1)),
"than the length of `z`")
})
test()
test_that("When z is simulated with hysteresis,
r cannot make the start sure again.", {
z <- z_sim(100, 5, start_regime = 0, start_hyst = TRUE)
expect_error(hystar_sim(z = z, r = c(-1, -.8), d = 1, phi_R0 = 0, phi_R1 = 0,
resvar = c(1, 1), start_regime = 1),
"used an hysteretic start")
})
test_that("When z is simulated with hysteresis,
r cannot make the start sure again.", {
z <- z_sim(100, 5, start_regime = 0, start_hyst = TRUE)
expect_error(hystar_sim(z = z, r = c(-.9, -.8), d = 1, phi_R0 = 0, phi_R1 = 0,
resvar = c(1, 1), start_regime = 1),
"used an hysteretic start")
})
test_that("When z is simulated, start_regime must match,
and that the correct starting regime is used.", {
z1 <- z_sim(100, 5, start_regime = 0, start_hyst = TRUE)
expect_warning(
s0 <- hystar_sim(z = z1, r = c(-.5, .5), d = 1, phi_R0 = 0, phi_R1 = 0,
resvar = c(1, 1), start_regime = 1),
"does not match"
)
expect_equal(s0$data$R[1], 0)
expect_warning(
s1 <- hystar_sim(z = z1, r = c(-.5, .5), d = 1, phi_R0 = 0, phi_R1 = 0,
resvar = c(1, 1), start_regime = 0),
NA
)
expect_equal(s1$data$R[1], 0)
z2 <- z_sim(100, 5, start_regime = 0, start_hyst = FALSE)
expect_warning(
s2 <- hystar_sim(z = z2, r = c(-.5, .5), d = 1, phi_R0 = 0, phi_R1 = 0,
resvar = c(1, 1), start_regime = 1),
"does not match"
)
expect_equal(s2$data$R[1], 0)
expect_warning(
s3 <- hystar_sim(z = z2, r = c(-.5, .5), d = 1, phi_R0 = 0, phi_R1 = 0,
resvar = c(1, 1)),
NA
)
expect_equal(s3$data$R[1], 0)
expect_warning(
s4 <- hystar_sim(z = z2, r = c(-.5, .5), d = 1, phi_R0 = 0, phi_R1 = 0,
resvar = c(1, 1), start_regime = 0),
NA
)
expect_equal(s4$data$R[1], 0)
})
test_that("When z is not simulated, and there is no hysteresis,
starting regime gives warning if it does not match", {
z <- 1:10
expect_warning( # r makes start regime certainly 0
s <- hystar_sim(z = z, r = c(2, 4), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 1),
"overruled"
)
expect_equal(s$data$R[1], 0)
expect_warning( # r makes start regime certainly 0
s <- hystar_sim(z = z, r = c(2, 4), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 0),
NA
)
expect_equal(s$data$R[1], 0)
})
test_that("When z is not simulated, and there is no hysteresis,
starting regime gives warning if it does not match", {
z <- 1:10
expect_warning( # r makes start regime certainly 0
s <- hystar_sim(z = z, r = c(2, 4), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 1),
"overruled"
)
expect_equal(s$data$R[1], 0)
expect_warning( # r makes start regime certainly 0
s <- hystar_sim(z = z, r = c(2, 4), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 0),
NA
)
expect_equal(s$data$R[1], 0)
})
test_that("When z is not simulated, and there is no hysteresis,
starting regime gives warning if it does not match", {
z <- 1:10
expect_warning( # r makes start regime certainly 0
s <- hystar_sim(z = z, r = c(2, 4), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 1),
"`start_regime` is different from what is implied"
)
expect_equal(s$data$R[1], 0)
expect_warning( # r makes start regime certainly 0
s <- hystar_sim(z = z, r = c(2, 4), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 0),
NA
)
expect_equal(s$data$R[1], 0)
})
test_that("When z is not simulated, and there is hysteresis,
starting regime must be provided.", {
z <- 5:10
s <- hystar_sim(z = z, r = c(2, 8), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 1)
expect_equal(s$data$R[1], 1)
expect_error(hystar_sim(z = z, r = c(2, 8), d = 1, phi_R0 = 0, phi_R1 = 0),
"`start_regime` was not provided")
})
test_that("When z is not simulated, and there is hysteresis,
starting regime must be provided.", {
z <- c(5, 1:10)
s <- hystar_sim(z = z, r = c(2, 8), d = 1, phi_R0 = 0, phi_R1 = 0,
start_regime = 1)
expect_equal(s$data$R[1], 1)
expect_error(hystar_sim(z = z, r = c(2, 8), d = 1, phi_R0 = 0, phi_R1 = 0),
"`start_regime` was not provided")
})
test_that("start check will return inferred start if incorrect start was provided,
and warn that start_regime was ignored", {
expect_warning(start <- check_hystar_sim_input(z = 1:5, r = c(6, 7), d = 1,
phi_R0 = 0, phi_R1 = 0, resvar = c(1, 1),
start_regime = 9)
)
expect_equal(start, 0)
})
test_that("start check will return inferred start if incorrect start was provided,
and warn that start_regime was ignored", {
expect_warning(start <- check_hystar_sim_input(z = 1:5, r = c(2, 3), d = 1,
phi_R0 = 0, phi_R1 = 0, resvar = c(1, 1),
start_regime = 9)
)
expect_equal(start, 0)
})
test_that("start_hyst must be TRUE or FALSE", {
expect_error(check_start_hyst(NA), "TRUE or FALSE")
expect_error(check_start_hyst("a"), "TRUE or FALSE")
})
test_that("range input must be valid", {
expect_error(z_sim(100, 4, 1, FALSE, c(3, 1), "not larger than the first"))
expect_error(z_sim(100, 4, 1, FALSE, 3, "a vector of length 2"))
})
test()
devtools::load_all(".")
test()
check()
devtools::check()
devtools::load_all(".")
?z_sim
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
test_that("Trailing zeros are correctly removed.", {
# Note that by default we want to keep the first value,
# regardless of its value!
expect_equal(remove_trailing_zeros(c(1, 2, 0, 0)),
c(1, 2))
expect_equal(remove_trailing_zeros(c(0, 0, 1, 3)),
c(0, 0, 1, 3))
expect_equal(remove_trailing_zeros(c(0, 0, 0, 0)),
0)
})
devtools::load_all(".")
test_that("order is correct", {
order <- get_order(coe = c(0, .4, .5))
expect_equal(order, 2)
order <- get_order(coe = c(0, .5, 0, 0))
expect_equal(order, 2)
order <- get_order(coe = c(0, 0, 0, 0))
expect_equal(order, 0)
})
test_that("order is correct", {
order <- get_order(coe = c(0, .4, .5))
expect_equal(order, 2)
order <- get_order(coe = c(0, .5, 0, 0))
expect_equal(order, 1)
order <- get_order(coe = c(0, 0, 0, 0))
expect_equal(order, 0)
})
test("test_helpers.R")
?test
test_active_file()
test_coverage_active_file()
test_coverage()
devtools::load_all(".")
hystar_sim(y = 2, z = 4, d = 1, phi_R0 = c(.3, .8), phi_R1 = 3)
hystar_sim(z = 4, d = 1, phi_R0 = c(.3, .8), phi_R1 = 3)
hystar_sim(z = 4:10, r = c(5, 7) d = 1, phi_R0 = c(.3, .8), phi_R1 = 3)
hystar_sim(z = 4:10, r = c(5, 7), d = 1, phi_R0 = c(.3, .8), phi_R1 = 3)
hystar_sim(z = 4:10, r = c(5, 7), d = 1, phi_R0 = c(.3, .8, . 4), phi_R1 = 3)
hystar_sim(z = 4:10, r = c(5, 7), d = 1, phi_R0 = c(.3, .8, .4), phi_R1 = 3)
devtools::load_all(".")
?hystar_sim
hystar_sim(z = 4:10, r = c(5, 7), d = 1, phi_R0 = c(.3, .8, .4, 0, 0), phi_R1 = 3)$orders
devtools::load_all(".")
hystar_sim(z = 4:10, r = c(5, 7), d = 1, phi_R0 = c(.3, .8, .4, 0, 0), phi_R1 = 3)$orders
devtools::check()
?axis
devtools::load_all(".")
sim
plot(sim)
devtools::load_all(".")
plot(sim)
devtools::load_all(".")
test_active_file()
test_that("switch points are correct", {
R <- c(0, 1, 1, 0, 1, 0, 0, 0, 1)
exp <- c(2, 4, 5, 6, 9)
expect_equal(get_sw_pnts(R), exp)
})
R <- c(0, 1, 1, 0, 1, 0, 0, 0, 1)
n <- length(R)
n
R <- c(0, 1, 1, 0, 1, 0, 0, 0, 1)
n <- length(R)
R <- R[2:n]
R_lag <- R[1:(n-1)]
S <- R - R_lag
S
R
R_lag
R
# Where are switches from 0 (1) to 1 (0)?
# We define a switch point as the time point where R is different
# from R at the previous time point.
# We don't want to use a slow for loop, so we vectorize the problem.
# Note that at a switch point s, R[s] - R[s-1] != 0.
# We compute S[t] = R[t] - R[t-1] and see were this is nonzero.
# We use the lagged version of R, so we add the first time
# point again (in which there can be no switch by definition).
n <- length(R)
R_t <- R[2:n]
R_lag <- R[1:(n-1)]
R_t
R_lag
R
S <- R_t - R_lag
S
sw_points <- which(S != 0)
sw_points
devtools::load_all(".")
test_that("switch points are correct", {
R <- c(0, 1, 1, 0, 1, 0, 0, 0, 1)
exp <- c(2, 4, 5, 6, 9)
expect_equal(get_sw_pnts(R), exp)
})
R_t
R_lag
S_ <- R_t - R_lag
devtools::load_all(".")
test_that("switch points are correct", {
R <- c(0, 1, 1, 0, 1, 0, 0, 0, 1)
exp <- c(2, 4, 5, 6, 9)
expect_equal(get_sw_pnts(R), exp)
})
test_that("switch point matrix is correct. Start 1, uneven switches", {
# switch points should be 2 3 4.
R <- c(1, 0, 1, 0, 0)
exp_mat <- matrix(c(1, 2,
3, 4),
ncol = 2, byrow = TRUE)
expect_equal(get_sw_pnts_mat(R), exp_mat)
})
test_that("switch point matrix is correct. Start 1, even switches", {
# switch points should be 2 3 4 5.
R <- c(1, 0, 1, 0, 1, 0)
exp_mat <- matrix(c(1, 2,
3, 4,
5, 6), # 6 is the last time point
ncol = 2, byrow = TRUE)
expect_equal(get_sw_pnts_mat(R), exp_mat)
})
test_that("switch point matrix is correct. Start 0, uneven switches", {
# switch points should be 2 3 4.
R <- c(0, 1, 0, 1, 1, 1)
exp_mat <- matrix(c(2, 3,
4, 6), # 6 is the last time point
ncol = 2, byrow = TRUE)
expect_equal(get_sw_pnts_mat(R), exp_mat)
})
test_that("switch point matrix is correct. Start 0, even switches", {
# switch points should be 2 3 4 5.
R <- c(0, 1, 0, 1, 0, 0)
exp_mat <- matrix(c(2, 3,
4, 5),
ncol = 2, byrow = TRUE)
expect_equal(get_sw_pnts_mat(R), exp_mat)
})
test_that("plot function does not return", {
z <- z_sim(n_t = 50, n_switches = 3,
start_regime = 1, start_hyst = TRUE,
range = c(-1, 1))
sim <- hystar_sim(z = z, r = c(-.5, .5), d = 5,
phi_R0 = c(0, .6), phi_R1 = c(1. -.3),
resvar = c(1, .9),
start_regime = 1)
fit <- hystar_fit(y = sim$data$y, z = z)
expect_equal(plot(sim), NULL)
expect_equal(plot(fit), NULL)
})
devtools::load_all(".")
test_active_file()
if (TRUE)
x <- 7
x
if (TRUE)
x <- 3
devtools::load_all(".")
test_active_file()
test_that("p_select must be a valid choice", {
expect_error(hystar_fit(y = 1, z = 3, p_select = 1),
"character")
expect_error(hystar_fit(y = 1, z = 3, p_select = "bla"),
"aic")
})
test_that("p_select must be a valid choice", {
expect_error(hystar_fit(y = 1, z = 3, p_select = 1),
"character")
expect_error(hystar_fit(y = 1, z = 3, p_select = "bla"),
"aic")
p_select <- check_hystar_fit_input(y = 1, z = 1, p_select = "a")
expect_equal(p_select, "aic")
})
test_that("p_select must be a valid choice", {
expect_error(hystar_fit(y = 1, z = 3, p_select = 1),
"character")
expect_error(hystar_fit(y = 1, z = 3, p_select = "bla"),
"aic")
p_select <- check_hystar_fit_input(
y = 1:4, z = 1:4, d = 1, p0 = 1, p1 = 1,
p_select = "a", r = c(2, 3), thin = TRUE
)
expect_equal(p_select, "aic")
})
test_that("p_select must be a valid choice", {
expect_error(hystar_fit(y = 1, z = 3, p_select = 1),
"character")
expect_error(hystar_fit(y = 1, z = 3, p_select = "bla"),
"aic")
p_select <- check_hystar_fit_input(
y = 1:4, z = 1:4, d = 1, p0 = 1, p1 = 1,
p_select = "a", r = c(.8, .9), thin = TRUE
)
expect_equal(p_select, "aic")
})
?substitute
?env
substitute(x, env = parent.env())
substitute(x, env = parent.env(x))
?parent.env()
env
env()
current.env()
parent.env(.GlobalEnv)
attr(get_sw_pnts, "scrref")
attr(get_sw_pnts, "srcref")
body(get_sw_pnts)
devtools::load_all(".")
check_hystar_fit_input(
y = 1:4, z = 1:4, d = 1, p0 = 1, p1 = 1,
p_select = "a", r = c(.8, .9), thin = TRUE
)
check_char_arg("aic", c("aic", "aicc", "bic"))
check_char_arg("bla", c("aic", "aicc", "bic"))
fn_env(check_char_arg)
library(rlang)
fn_env(check_char_arg)
parent.env(.GlobalEnv)
parent.env(emptyenv())
A <- function(test) {
B(test)
}
B <- function(x) {
print(substitute(x))
}
B(3)
B(3)
B <- function(x) {
paste(substitute(x))
}
B(3)
B(x = 3)
a <- 2
B(a)
B(A(a))
a <- 2
B(A(a))
A <- function(test) {
B(test)
}
B <- function(x) {
paste(substitute(x))
}
a <- 2
B(A(a))
a <- "daan"
check_char_arg(a, c("hoi", "daan"))
check_char_arg(a, c("hoi", "sdd"))
B <- function(x) {
paste(substitute(x, env = parent.frame()))
}
a <- "daan"
B(A(a))
devtools::load_all(".")
check_char_arg(a, c("hoi", "sdd"))
hystar_fit(y = 1, z = 3, p_select = "bla")
?substitute
devtools::load_all(".")
test_that("p_select must be a valid choice", {
expect_error(hystar_fit(y = 1, z = 3, p_select = 1),
"character")
expect_error(hystar_fit(y = 1, z = 3, p_select = "bla"),
"aic")
p_select <- check_hystar_fit_input(
y = 1:4, z = 1:4, d = 1, p0 = 1, p1 = 1,
p_select = "a", r = c(.8, .9), thin = TRUE
)
expect_equal(p_select, "aic")
})
expect_error(hystar_fit(y = 1, z = 3, p_select = 1),
"character")
expect_error(hystar_fit(y = 1, z = 3, p_select = "bla"),
"aic")
check_hystar_fit_input(
y = 1:4, z = 1:4, d = 1, p0 = 1, p1 = 1,
p_select = "a", r = c(.8, .9), thin = TRUE
)
check_p_select("ai")
match.arg("d", c("daan", "joe"))
devtools::load_all(".")
check_p_select("ai")
devtools::load_all(".")
check_p_select("ai")
devtools::load_all(".")
check_p_select("ai")
devtools::load_all(".")
check_hystar_fit_input(
y = 1:4, z = 1:4, d = 1, p0 = 1, p1 = 1,
p_select = "a", r = c(.8, .9), thin = TRUE
)
p_select = "a"
if (!is.character(p_select))
stop(paste0("`p_select` must be of type character."),
call. = FALSE)
choices <- c("aic", "aicc", "bic")
p_select <- tolower(p_select)
p_select
match.arg(
arg = p_select,
choices = choices
)
p_select
devtools::load_all(".")
match.arg(
arg = p_select,
choices = choices
)
check_p_select("ai")
?match.arg
